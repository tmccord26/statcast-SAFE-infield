---
title: "Modeling the Probability of a Ground Ball Being a Successful Play"
format: html
---

```{r}
library(tidyverse)
library(lme4)
library(broom.mixed)
library(mgcv)
library(ks)

bip_gb <- readRDS("statcast_data/bip_gb.rds")
safe_positioning <- readRDS("statcast_data/player_positioning/safe_positioning.rds")
sc_positioning <- readRDS("statcast_data/player_positioning/sc_positioning.rds")
```

## Example: Successful Play Probability Model for SS in 2025

```{r}
# Fitting a model for shortstops (SS) in 2025

pos_ss <- safe_positioning |>
  filter(play_made_by == "SS")

bip_gb_ss_2025 <- bip_gb |>
  filter(
    game_year == 2025,
    (successful_play == 1 & play_made_by == "SS") | (successful_play == 0)
  ) |>
  mutate(
    pos_x = pos_ss$pos_x,
    pos_y = pos_ss$pos_y,
    pos_angle = pos_ss$pos_angle,
    theta = abs(pos_angle - spray_angle),
    move_left = ifelse(spray_angle < pos_angle, 1, 0),
    fielder_id = as.factor(fielder_6)
  ) |>
  # filter out NA for all variables used in the model
  filter(
    !is.na(launch_speed),
    !is.na(theta),
    theta <= 45
  ) |>
  # scaling continuous variables
  mutate(
    launch_speed_scaled = scale(launch_speed)[,1],
    theta_scaled = scale(theta)[,1]
  )

players_num_plays <- bip_gb_ss_2025 |>
  group_by(fielder_id) |>
  summarise(num_plays = n()) |>
  arrange(num_plays) |>
  filter(num_plays >= 10) |>
  pluck("fielder_id")

bip_gb_ss_2025 <- bip_gb_ss_2025 |>
  filter(fielder_id %in% players_num_plays)
```


### Probit Regression (with full random effects)

```{r}

# Probit regression model with full random effects
model_ss_2025_re_full <- glmer(
  out_ss ~ theta_scaled + theta_scaled:move_left + 
    theta_scaled:launch_speed_scaled + theta_scaled:launch_speed_scaled:move_left +
    (1 + theta_scaled || fielder_id),
  data = bip_gb_ss_2025,
  family = binomial(link = "probit"),
  control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 2e5))
)

summary(model_ss_2025_re_full)
```


### Visualizing Random Intercepts

```{r}

# get random effects with standard errors for each fielder
re_fielder <- ranef(model_ss_2025_re_full, condVar = TRUE)$fielder_id

se_fielder <- sqrt(sapply(attr(re_fielder, "postVar"), function(x) x[1, 1, ]))

fielder_effects <- data.frame(
  fielder_id = rownames(re_fielder),
  random_intercept = re_fielder[, 1],
  random_theta = re_fielder[, 2],
  se = se_fielder
)

```

```{r}
#| label: fig-random-intercepts
#| fig-cap: "Random Intercepts for SS Fielders in 2025 with 95% Confidence Intervals"
#| fig-width: 8
#| fig-height: 6

ggplot(fielder_effects, aes(x = reorder(fielder_id, random_intercept), y = random_intercept)) +
  geom_point() +
  geom_errorbar(aes(ymin = random_intercept - 1.96 * `se..Intercept.`, ymax = random_intercept + 1.96 * `se..Intercept.`), width = 0.2) +
  coord_flip() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(
    title = "Random Intercepts for SS Fielders with 95% CI",
    x = "Fielder ID",
    y = "Random Intercept (u_i)"
  ) +
  theme_classic() +
  theme(
    axis.text.y = element_blank()
  )
```

```{r}
#| label: fig-random-slopes
#| fig-cap: "Random Slopes for Theta SS Fielders in 2025 with 95% Confidence Intervals"
#| fig-width: 8
#| fig-height: 6

ggplot(fielder_effects, aes(x = reorder(fielder_id, random_theta), y = random_theta)) +
  geom_point() +
  geom_errorbar(aes(ymin = random_theta - 1.96 * `se.theta_scaled`, ymax = random_theta + 1.96 * `se.theta_scaled`), width = 0.2) +
  coord_flip() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(
    title = "Random Slopes for Theta SS Fielders with 95% CI",
    x = "Fielder ID",
    y = "Random Slope (u_theta)"
  ) +
  theme_classic() +
  theme(
    axis.text.y = element_blank()
  )
```

## SAFE Metric Calculation

### 2D Kernel Density of Ground Balls by Spray Angle and Launch Speed

```{r}

XY <- cbind(bip_gb$spray_angle, bip_gb$launch_speed)
kde_fit <- kde(x = XY)

# Search grid
launch_speeds <- seq(50, 110, 1)
spray_angles  <- seq(-45, 45, 1)

batted_balls <- expand.grid(
  spray_angle = spray_angles,
  launch_speed = launch_speeds
)

# Evaluate KDE directly at each grid point
batted_balls$density <- predict(
  kde_fit,
  x = cbind(batted_balls$spray_angle,
            batted_balls$launch_speed)
)

# plot the densities
ggplot(batted_balls, aes(x = spray_angle, y = launch_speed, fill = density)) +
  geom_tile() +
  scale_fill_viridis_c() +
  labs(
    title = "2D Kernel Density Estimate of Ground Balls by Spray Angle and Launch Speed",
    x = "Spray Angle (degrees)",
    y = "Launch Speed (mph)",
    fill = "Density"
  ) +
  theme_minimal()

```


### Fitting a Run Value Model

```{r}
# Fitting a run expectancy model
mod_run_value <- gam(delta_run_exp ~ s(launch_speed) +
                                     s(spray_angle) + 
                                     launch_speed:spray_angle,
                     data = bip_gb)

batted_balls$run_value <- predict(mod_run_value, newdata = batted_balls)
```


### Function to Fit SAFE Model for a Given Position and Year

```{r}
fit_SAFE <- function(bip_data, year, position, positioning_data, batted_balls, max_retries = 3) {
  
  # Merge position coordinates onto play data, filter to year, and compute features
  play_data <- bip_data |>
    filter(
      (successful_play == 1 & play_made_by == position) | (successful_play == 0)
    ) |>
    mutate(
      pos_x = positioning_data$pos_x,
      pos_y = positioning_data$pos_y,
      pos_angle = positioning_data$pos_angle,
      theta = abs(pos_angle - spray_angle),
      move_left = ifelse(spray_angle < pos_angle, 1, 0),
      fielder_id = case_when(
        position == "1B" ~ fielder_3,
        position == "2B" ~ fielder_4,
        position == "3B" ~ fielder_5,
        position == "SS" ~ fielder_6,
        TRUE ~ NA
      )
    ) |>
    # scaling continuous variables
    mutate(
      launch_speed_scaled = scale(launch_speed)[,1],
      theta_scaled = scale(theta)[,1]
    ) |>
    # filter out NA for all variables used in the model
    filter(
      !is.na(fielder_id),
      !is.na(launch_speed),
      !is.na(theta)
    )
  
  players_num_plays <- play_data |>
    group_by(fielder_id) |>
    summarise(num_plays = n()) |>
    arrange(num_plays) |>
    filter(num_plays >= 10) |>
    pluck("fielder_id")

  play_data <- play_data |>
    filter(fielder_id %in% players_num_plays) |>
    mutate(fielder_id = factor(fielder_id))
  
  # ---------------------------- PROBABILITY MODEL -----------------------------
  
  # Create the outcome variable name dynamically
  outcome_var <- paste0("out_", str_to_lower(position))
  
  formula_str_player <- paste0(
    outcome_var, " ~ 1 + theta_scaled + theta_scaled:move_left + ",
    "theta_scaled:launch_speed_scaled + theta_scaled:launch_speed_scaled:move_left + ",
    "(1 + theta_scaled || fielder_id)"
  )
  
  mod_player <- NULL
  attempt <- 1
  
  while(is.null(mod_player) && attempt <= max_retries) {
    
    tryCatch({
      
      if (attempt == 1) {
        # First attempt: default bobyqa
        message(paste("Fitting model for", position, year, "- Attempt", attempt))
        mod_player <- glmer(
          formula = as.formula(formula_str_player),
          data = play_data,
          family = binomial(link = "probit"),
          control = glmerControl(
            optimizer = "bobyqa",
            optCtrl = list(maxfun = 2e5)
          )
        )
        
      } else if (attempt == 2) {
        # Second attempt: Simplify random effects (intercept only)
        message(paste("Retrying with simplified random effects for", position, year))
        formula_str_simple <- paste0(
          outcome_var, " ~ 1 + theta_scaled + theta_scaled:move_left + ",
          "theta_scaled:launch_speed_scaled + theta_scaled:launch_speed_scaled:move_left + ",
          "(1 | fielder_id)"  # Only random intercept
        )
        mod_player <- glmer(
          formula = as.formula(formula_str_simple),
          data = play_data,
          family = binomial(link = "probit"),
          control = glmerControl(
            optimizer = "bobyqa",
            optCtrl = list(maxfun = 2e5)
          )
        )
      }
      
    }, error = function(e) {
      message(paste("Attempt", attempt, "failed for", position, year, ":", e$message))
      mod_player <<- NULL
    })
    
    attempt <- attempt + 1
  }
  
  # If all attempts failed, return empty results
  if (is.null(mod_player)) {
    warning(paste("All attempts failed for", position, year, "- returning empty results"))
    return(data.frame(
      fielder_id = character(),
      position = character(),
      year = numeric(),
      SAFE = numeric()
    ))
  }
  
  message(paste("Successfully fit model for", position, year))
  
  
  # ---------------------- CALCULATING SAFE METRICS ----------------------------
  
  batted_balls <- batted_balls |>
    mutate(
      pos_angle = positioning_data$pos_angle,
      theta = abs(pos_angle - spray_angle),
      move_left = ifelse(spray_angle < pos_angle, 1, 0),
      # standardize variables based on training data
      launch_speed_scaled = (launch_speed - mean(play_data$launch_speed, na.rm = TRUE)) / sd(play_data$launch_speed, na.rm = TRUE),
      theta_scaled = (theta - mean(play_data$theta, na.rm = TRUE)) / sd(play_data$theta, na.rm = TRUE)
    )
  
  fielders <- unique(play_data$fielder_id)
  
  # Set up a data frame to store SAFE results
  safe_results <- data.frame()
  
  for (fielder in fielders) {
    
    bb_temp <- batted_balls
    bb_temp$fielder_id <- factor(fielder, levels = levels(play_data$fielder_id))
    n_opportunities <- nrow(play_data |> filter(fielder_id == fielder))
    
    # Check that this fielder exists in the model
    if (!(fielder %in% levels(play_data$fielder_id))) {
      next
    }
    
    bb_temp <- bb_temp |>
      mutate(
        prob_play_player = predict(mod_player, newdata = bb_temp, type = "response"),
        prob_play_avg = predict(mod_player, newdata = bb_temp, type = "response", re.form = NA),
        prob_play_added = prob_play_player - prob_play_avg,
        SAFE = prob_play_added * run_value * density
      ) 
    
    player_res <- bb_temp |>
      summarize(
        SAFE = sum(SAFE, na.rm = TRUE) * n_opportunities
      )
    
    # append fielderid, position, SAFE, and num_plays to safe_results
    safe_results <- rbind(safe_results, data.frame(
      fielder_id = as.character(fielder),
      position = position,
      year = year,
      SAFE = player_res$SAFE
    ))

  }
  
  return(safe_results)
  
}
```


```{r}
years <- c(2023, 2024, 2025)
positions <- c("1B", "2B", "SS", "3B")

# Initialize results storage
all_safe_results <- data.frame()

for (year in years) {
  
  bip_gb_year <- bip_gb |>
    filter(game_year == year)
  
  for (position in positions) {
    
    safe_pos_year <- safe_positioning |>
      filter(play_made_by == !!position)
    
    safe_results <- fit_SAFE(
      bip_data = bip_gb_year,
      year = year,
      position = position,
      positioning_data = safe_pos_year,
      batted_balls = batted_balls
    )
    
    # Accumulate results
    all_safe_results <- rbind(all_safe_results, safe_results)
  }
  
}

saveRDS(all_safe_results, "results/safe_results.rds")
```

## Player-Specific Locations


```{r}
#| label: fig-statcast-positioning
# visualizing player positioning for SS

bases <- data.frame(
  x = c(-63.64, 0, 63.64, 0, -63.64),
  y = c(63.64, 127.28, 63.64, 0, 63.64)
)

sc_positioning |>
  ggplot(aes(x = pos_x, y = pos_y, color = position)) +
  geom_point() +
  geom_path(data = bases, aes(x = x, y = y), color = "black", linewidth = 1) +
  geom_point(data = bases[1:4,], aes(x = x, y = y), 
             color = "black", size = 3, shape = 15, inherit.aes = FALSE) +
  facet_wrap(~batter_hand) +
  theme_classic() +
  theme(
    axis.title.x = element_blank(),
    axis.text.x = element_blank(),
    axis.title.y = element_blank(),
    axis.text.y = element_blank()
  ) +
  coord_fixed(ratio = 1) +
  labs(
    title = "Player-Specific Positioning Based on Statcast Data",
    color = "Position"
  )
```


```{r}
# Merge position coordinates onto play data, filter to year, and compute features

fit_SAFE_sc_pos <- function(bip_data, year, sc_positioning, pos_position, bb_space) {
  
  sc_pos_position <- sc_positioning |>
    filter(year == !!year, position == !!pos_position)
  
  play_data <- bip_data |>
    filter(
      (successful_play == 1 & play_made_by == pos_position) | (successful_play == 0)
    ) |>
    mutate(
      fielder_id = case_when(
        pos_position == "1B" ~ fielder_3,
        pos_position == "2B" ~ fielder_4,
        pos_position == "3B" ~ fielder_5,
        pos_position == "SS" ~ fielder_6,
        TRUE ~ NA
      )
    ) |>
    left_join(sc_pos_position, 
              by = c("fielder_id", "stand" = "batter_hand"),
              relationship = "many-to-many") |>
    mutate(
      theta = abs(pos_angle - spray_angle),
      move_left = ifelse(spray_angle < pos_angle, 1, 0),
      launch_speed_scaled = scale(launch_speed)[,1],
      theta_scaled = scale(theta)[,1]
    ) |>
    filter(
      !is.na(fielder_id),
      !is.na(launch_speed),
      !is.na(theta)
    )
  
  players_num_plays <- play_data |>
    group_by(fielder_id) |>
    summarise(num_plays = n()) |>
    arrange(num_plays) |>
    filter(num_plays >= 10) |>
    pluck("fielder_id")
  
  play_data <- play_data |>
    filter(fielder_id %in% players_num_plays) |>
    mutate(fielder_id = factor(fielder_id))
  
  # Finding average positioning for all positions
  avg_positioning <- sc_pos_position |>
    filter(position == !!pos_position, year == !!year) |>
    group_by(batter_hand) |>
    summarise(
      avg_pos_angle = mean(pos_angle, na.rm = TRUE),
      avg_pos_x = mean(pos_x, na.rm = TRUE),
      avg_pos_y = mean(pos_y, na.rm = TRUE),
      .groups = "drop"
    )
  
  # ---------------------------- PROBABILITY MODEL -----------------------------
  
  # Create the outcome variable name dynamically
  outcome_var <- paste0("out_", str_to_lower(pos_position))
  
  formula_str_player <- paste0(
    outcome_var, " ~ 1 + theta_scaled + theta_scaled:move_left + ",
    "theta_scaled:launch_speed_scaled + theta_scaled:launch_speed_scaled:move_left + ",
    "(1 + theta_scaled || fielder_id)"
  )
  
  mod_player <- NULL
  attempt <- 1
  
  while(is.null(mod_player) && attempt <= 2) {
    
    tryCatch({
      
      if (attempt == 1) {
        # First attempt: default bobyqa
        message(paste("Fitting model for", position, year, "- Attempt", attempt))
        mod_player <- glmer(
          formula = as.formula(formula_str_player),
          data = play_data,
          family = binomial(link = "probit"),
          control = glmerControl(
            optimizer = "bobyqa",
            optCtrl = list(maxfun = 2e5)
          )
        )
        
      } else if (attempt == 2) {
        # Second attempt: Simplify random effects (intercept only)
        message(paste("Retrying with simplified random effects for", position, year))
        formula_str_simple <- paste0(
          outcome_var, " ~ 1 + theta_scaled + theta_scaled:move_left + ",
          "theta_scaled:launch_speed_scaled + theta_scaled:launch_speed_scaled:move_left + ",
          "(1 | fielder_id)"  # Only random intercept
        )
        mod_player <- glmer(
          formula = as.formula(formula_str_simple),
          data = play_data,
          family = binomial(link = "probit"),
          control = glmerControl(
            optimizer = "bobyqa",
            optCtrl = list(maxfun = 2e5)
          )
        )
      }
      
    }, error = function(e) {
      message(paste("Attempt", attempt, "failed for", position, year, ":", e$message))
      mod_player <<- NULL
    })
    
    attempt <- attempt + 1
  }
  
  # If all attempts failed, return empty results
  if (is.null(mod_player)) {
    warning(paste("All attempts failed for", position, year, "- returning empty results"))
    return(data.frame(
      fielder_id = character(),
      position = character(),
      year = numeric(),
      SAFE = numeric()
    ))
  }
  
  message(paste("Successfully fit model for", position, year))
  
  
  # ---------------------- CALCULATING SAFE METRICS ----------------------------
  
  # Create bb_avg with predictions - keep identifying columns for joining
  bb_avg <- bb_space |>
    mutate(row_id = row_number()) |>  # Add row identifier
    left_join(avg_positioning, by = "batter_hand") |>
    mutate(
      theta = abs(avg_pos_angle - spray_angle),
      theta_scaled = (theta - mean(play_data$theta, na.rm = TRUE)) / 
                     sd(play_data$theta, na.rm = TRUE),
      move_left = ifelse(spray_angle < avg_pos_angle, 1, 0)
    )
  
  bb_avg$prob_play_avg <- predict(mod_player, newdata = bb_avg, type = "response", re.form = NA)
  
  # Keep only necessary columns for joining
  bb_avg_join <- bb_avg |>
    dplyr::select(row_id, prob_play_avg)
  
  players <- unique(play_data$fielder_id)
  
  safe_results <- data.frame()
  
  for (player in players) {
    
    pos_player <- sc_pos_position |>
      filter(fielder_id == player) |>
      dplyr::select(batter_hand, pos_x, pos_y, pos_angle)
    
    bb_player <- bb_space |>
      mutate(row_id = row_number()) |>  # Add same row identifier
      left_join(
        pos_player,
        by = c("batter_hand"),
        relationship = "many-to-many"
      ) |>
      mutate(
        theta = abs(pos_angle - spray_angle),
        theta_scaled = (theta - mean(play_data$theta, na.rm = TRUE)) / 
                       sd(play_data$theta, na.rm = TRUE),
        move_left = ifelse(spray_angle < pos_angle, 1, 0),
        fielder_id = factor(player, levels = levels(play_data$fielder_id))
      )
    
    bb_player$prob_play_player <- predict(mod_player, newdata = bb_player, type = "response")
    
    n_opportunities <- nrow(play_data |> filter(fielder_id == player))
    
    # Join by row_id to match correct probabilities
    bb_temp <- bb_player |>
      left_join(bb_avg_join, by = "row_id") |>
      mutate(
        prob_play_added = prob_play_player - prob_play_avg,
        SAFE = prob_play_added * run_value * density
      )
    
    player_res <- bb_temp |>
      summarize(
        SAFE = sum(SAFE, na.rm = TRUE) * n_opportunities
      )
    
    safe_results <- rbind(safe_results, data.frame(
      fielder_id = as.character(player),
      position = pos_position,
      year = year,
      SAFE = player_res$SAFE
    ))
  }
  
  return(safe_results)
}
```


```{r}
# Initialize results storage
all_safe_sc_results <- data.frame()

# duplicate batted_balls with lhh and rhh
bb_space <- batted_balls |>
    slice(rep(1:n(), each = 2)) |>
    mutate(
      batter_hand = rep(c("L", "R"), times = nrow(batted_balls)),
      launch_speed_scaled = (launch_speed - mean(play_data$launch_speed, na.rm = TRUE)) / 
                             sd(play_data$launch_speed, na.rm = TRUE)
    )

for (year in years) {
  
  bip_gb_year <- bip_gb |>
    filter(game_year == year)
  
  for (position in positions) {
    
    safe_results <- fit_SAFE_sc_pos(
      bip_data = bip_gb_year,
      year = year,
      pos_position = position,
      sc_positioning = sc_positioning,
      bb_space = bb_space
    )
    
    # Accumulate results
    all_safe_sc_results <- rbind(all_safe_sc_results, safe_results)
  }
  
}

saveRDS(all_safe_sc_results, "statcast_data/player_positioning/sc_positioning_safe_results.rds")
```



## Results

```{r}
player_id_map <- sc_positioning |>
  mutate(fielder_id = as.character(fielder_id)) |>
  select(fielder_id, name_fielder) |>
  distinct()

all_safe_results |>
  left_join(player_id_map, by = "fielder_id") |>
  arrange(desc(SAFE)) |>
  head(10) |>
  select(name_fielder, position, year, SAFE)
```

